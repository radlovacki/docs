# Selection Sort

Сортирање било којих ставки у односу на неко линерано уређење може да помогне човеку или рачунару да брзо пронађе жељене ставке:

- сортирање низа бројева у растућем или опадајућем редоследу,
- сортирање стрингова лексикографски,
- сортирање низа структура на основу вредности неког поља итд.

Постоји више алгоритама којим можеш да сортираш елементе низа бројева у растућем или опадајућем редоследу, а један од најједноставнијих је алгоритам за сортирање избором *(енгл. Selection Sort)*. У овој лекцији научићеш:

- како функционише алгоритам за сортирање избором,
- како да имплементираш овај алгоритам у програмском језику C,
- како да имплементираш овај алгоритам користећи наредбе циклуса `for` и `while` и користећи функције и
- колико је овај алгоритам ефикасан.

## Опис алгоритма

Нека је дат несортиран низ од `n` бројева и целобројна променљива `ind`.

- У `ind` памтимо индекс првог елемента. Поредимо све следеће елементе у низу са елементом са индексом `ind`. Ако је неки од њих мањи, његов индекс памтимо у `ind`.

- Ако је `ind` различит од индекса првог елемента, мењамо места првом елементу и елементу са индексом `ind`.

- У `ind` памтимо индекс другог елемента. Поредимо све следеће елементе у низу са елементом са индексом `ind`. Ако је неки од њих мањи, његов индекс памтимо у `ind`.

- Ако је `ind` различито од индекса другог елемента, мењамо места другом елементу и елементу са индексом `ind`.

- ...

- Овај поступак понављамо закључно са предпоследњим елементом, након чега ће низ бити сортиран.

Демонстрираћемо овај алгоритам на примеру. Нека је дат несортиран низ целих бројева: `arr[5] = { 5, 2, 9, 6, 4 }`. У `ind` памтимо индекс првог елемента `0`. Поредимо све следеће елементе у низу са елементом са индексом `0`. Ако је неки од њих мањи, његов индекс памтимо у `ind`:

```text
arr[5] = { 5, 2, 9, 6, 4 }    ind = 0    2 < 5 ? DA    ind = 1
                                         9 < 2 ? NE
                                         6 < 2 ? NE
                                         4 < 2 ? NE
```

Пошто је `ind` различито од `0` мењамо места елементима са индексом `0` и индексом `1`, па сада низ изгледа овако `arr[5] = { 2, 5, 9, 6, 4 }`.

У `ind` памтимо индекс другог елемента `1`. Поредимо све следеће елементе у низу са елементом са индексом `ind`. Ако је неки од њих мањи, његов индекс памтимо у `ind`:

```text
arr[5] = { 2, 5, 9, 6, 4 }    ind = 1    9 < 5 ? NE
                                         6 < 5 ? NE
                                         4 < 5 ? DA    ind = 4
```

Пошто је `ind` различито од `1` мењамо места елементима са индексом `1` и индексом `4`, па сада низ изгледа овако `arr[5] = { 2, 4, 9, 6, 5 }`.

У `ind` памтимо индекс трећег елемента `2`. Поредимо све следеће елементе у низу са елементом са индексом `ind`. Ако је неки од њих мањи, његов индекс памтимо у `ind`:

```text
arr[5] = { 2, 4, 9, 6, 5 }    ind = 2    6 < 9 ? DA    ind = 3
                                         5 < 6 ? DA    ind = 4
```

Пошто је `ind` различито од `2` мењамо места елементима са индексом `2` и индексом `4`, па сада низ изгледа овако `arr[5] = { 2, 4, 5, 6, 9 }`.

У `ind` памтимо индекс предпоследњег елемента `3`. Поредимо последњи елемент у низу са елементом са индексом `ind`. Ако је последњи мањи, његов индекс памтимо у `ind`:

```text
arr[5] = { 2, 4, 5, 6, 9 }    ind = 3    9 < 6 ? NE
```

Пошто је `ind` једнако са `3` у овом кораку нема замене.

## Имплементација у програмском језику C

```c
#include <stdio.h>

int main(void)
{
    int arr[] = { 5, 2, 9, 6, 4 };
    int n = sizeof(arr) / sizeof(arr[0]);
    for (int i = 0; i < n - 1; i++)
    {
        int ind = i;
        for (int j = i + 1; j < n; j++)
            if (arr[j] < arr[ind])
                ind = j;
        if (ind != i)
        {
            int temp = arr[i];
            arr[i] = arr[ind];
            arr[ind] = temp;
        }
    }
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);
    return 0;
}
```

## Имплементација са `for` петљама

Претходни алгоритам могуће је "упростити" избацивањем помоћне променљиве што би за последицу имало већи број замена. Нека је дат несортиран низ бројева.

- Вредност првог елемента низа поредимо са сваким следећим. Ако је неки од њих мањи, мењамо им места.

- Вредност другом елемента низа поредимо са сваким следећим. Ако је неки од њих мањи, мењамо им места.

- ...

- Овај поступак понављамо закључно са предпоследњим елементом, након чега ће низ бити сортиран.

У претходном решењу користили смо додатну променљиву и имали смо три замене, док у следећем немамо додатну променљиву али зато имамо пет замена:

```c
#include <stdio.h>

int main(void)
{
    int arr[] = { 5, 2, 9, 6, 4 };
    int n = sizeof(arr) / sizeof(arr[0]);
    for (int i = 0; i < n - 1; i++)
        for (int j = i + 1; j < n; j++)
            if (arr[j] < arr[i])
            {
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);
    return 0;
}
```

## Имплементација са `while` петљама

Претходни пример са `for` петљама лако се може превести у пример са `while` петљама:

```c
#include <stdio.h>

int main(void)
{
    int arr[] = { 5, 2, 9, 6, 4 };
    int n = sizeof(arr) / sizeof(arr[0]);
    int i = 0, j = 0;
    while (i < n)
    {
        int j = i + 1;
        while (j < n)
        {
            if (arr[j] < arr[i])
            {
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
            j++;
        }
        i++;
    }
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);
    return 0;
}
```
